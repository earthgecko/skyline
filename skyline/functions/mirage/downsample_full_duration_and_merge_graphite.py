"""
downsample_full_duration_and_merge_graphite
"""
import logging

from msgpack import Unpacker

from settings import FULL_NAMESPACE
from skyline_functions import nonNegativeDerivative, sort_timeseries
from functions.timeseries.determine_data_frequency import determine_data_frequency
from functions.timeseries.downsample import downsample_timeseries

skyline_app = 'mirage'
skyline_app_logger = '%sLog' % skyline_app
logger = logging.getLogger(skyline_app_logger)


# @added 20220414 - Feature #3866: MIRAGE_ENABLE_HIGH_RESOLUTION_ANALYSIS
#                   Task #3868: POC MIRAGE_ENABLE_HIGH_RESOLUTION_ANALYSIS
# To overcome the Graphite unfilled last bucket problem, the FULL_DURATION
# data is downsampled using the Pandas origin='end' backwards resample
# method and then aligning to the resolution and this data replaces the
# FULL_DURATION period in the Graphite timeseries data for analysis only.
# This solves the problem of false positive alerts being generated by
# unfilled buckets where the data in the bucket would 'normalise' over
# the duration of the bucket.  However often times occur where the
# bucket data only has one or two very high or very low values and then
# the average for that unfilled bucket is skewed, causing an outlier.
# When the the rest of the bucket is filled the outlier is flattened.
# This preprocessing method resolves that issue and removes any
# requirement for extending the Graphite first retention period to a
# value > 7days, which resolves this issue but creates an issue in the
# Ionosphere context where features extraction takes a long time and is
# not suitable for high production workload.  Thanks to Pandas for
# introducing backswards resampling in version 1.3.
# TODO, instead of doing this every time.... ONLY do it if the Graphite
# data pings as anomalous .... hmmm
def downsample_full_duration_and_merge_graphite(self, metric, timeseries, known_derivative_metric):
    """
    Returns a list of base_names that are metrics that defined in
    DO_NOT_ALERT_ON_STALE_METRICS

    :param current_skyline_app: the app calling the function
    :param external_settings: the external_settings dict
    :param unique_base_names: the unique_base_names list
    :type current_skyline_app: str
    :type external_settings: dict
    :type unique_base_names: list
    :return: do_not_alert_on_stale_metrics_list
    :rtype: list

    """
    metric_resolution = 0
    full_duration_resolution = 60  # default to 60
    resampled_aligned_timeseries = []
    downsampled_timeseries = []
    full_duration_timeseries = []
    redis_metric_name = '%s%s' % (FULL_NAMESPACE, str(metric))

    try:
        metric_resolution = determine_data_frequency(skyline_app, timeseries, False)
    except Exception as err:
        logger.error('error :: determine_data_frequency failed for %s - %s' % (
            metric, err))
        metric_resolution = 0
    logger.info('Graphite data resolution is %s seconds for %s' % (
        str(metric_resolution), metric))
    try:
        full_duration_resolution_str = self.redis_conn_decoded.hget('analyzer.metrics_manager.resolutions', metric)
        if full_duration_resolution_str:
            full_duration_resolution = int(float(full_duration_resolution_str))
    except Exception as err:
        logger.error('error :: failed to determine current_resolution from analyzer.metrics_manager.resolutions Redis hash for %s - %s' % (
            metric, err))
    logger.info('Redis FULL_DURATION data resolution is %s seconds for %s' % (
        str(full_duration_resolution), metric))
    if metric_resolution != full_duration_resolution:
        # Get the Redis FULL_DURATION timeseries data for the metric
        logger.info('downsampling Redis FULL_DURATION data to %s seconds and aligning to replace Graphite FULL_DURATION period for %s' % (
            str(metric_resolution), metric))
        try:
            raw_series = self.redis_conn.get(redis_metric_name)
            unpacker = Unpacker(use_list=False)
            unpacker.feed(raw_series)
            full_duration_timeseries = list(unpacker)
            if full_duration_timeseries:
                full_duration_timeseries = sort_timeseries(full_duration_timeseries)
            logger.info('got %s data points from Redis FULL_DURATION data for %s to downsample' % (
                str(len(full_duration_timeseries)), metric))
            logger.info('Redis FULL_DURATION data last data points for %s: %s' % (
                metric, str(full_duration_timeseries[-12:])))
        except Exception as err:
            logger.error('error :: failed to get full duration timeseries data from Redis for %s - %s' % (
                metric, err))
    else:
        logger.info('not preprocessing data because metric_resolution is %s seconds for %s' % (
            str(metric_resolution), metric))

    if full_duration_timeseries:
        method = 'mean'
        # if known_derivative_metric:
        #    method = 'sum'
        try:
            resampled_aligned_timeseries = downsample_timeseries(skyline_app, full_duration_timeseries, full_duration_resolution, metric_resolution, method, origin='end')
        except Exception as err:
            logger.error('error :: downsample_timeseries failed on full_duration_timeseries - %s' % err)
        logger.info('FULL_DURATION data for %s downsampled to %s data points at %s seconds' % (
            metric, str(len(resampled_aligned_timeseries)), str(metric_resolution)))
        logger.info('Graphite data last data points for %s: %s' % (
            metric, str(timeseries[-5:])))
        logger.info('downsampled FULL_DURATION data last data points for %s: %s' % (
            metric, str(resampled_aligned_timeseries[-5:])))

    # @added 20220506 - Feature #3866: MIRAGE_ENABLE_HIGH_RESOLUTION_ANALYSIS
    #                   Task #3868: POC MIRAGE_ENABLE_HIGH_RESOLUTION_ANALYSIS
    # Remove all nan because they break histogram_bins
    removed_nans = 0
    if resampled_aligned_timeseries:
        resampled_aligned_timeseries_no_nans = []
        for ts, v in resampled_aligned_timeseries:
            if str(v) == 'nan':
                removed_nans += 1
                continue
            resampled_aligned_timeseries_no_nans.append([ts, v])
    if removed_nans:
        logger.info('removed %s nan values from downsampled FULL_DURATION data for %s' % (
            str(removed_nans), metric))
        resampled_aligned_timeseries = resampled_aligned_timeseries_no_nans

    # The resampled_aligned_timeseries data must have nonNegativeDerivative
    # applied if it is a derivative_metric
    if resampled_aligned_timeseries and known_derivative_metric:
        logger.info('running nonNegativeDerivative on resampled data %s' % (
            metric))
        try:
            derivative_resampled_aligned_timeseries = nonNegativeDerivative(resampled_aligned_timeseries)
            resampled_aligned_timeseries = derivative_resampled_aligned_timeseries
            logger.info('resampled_aligned_timeseries data last data points for %s (after nonNegativeDerivative): %s' % (
                metric, str(resampled_aligned_timeseries[-12:])))
        except Exception as err:
            logger.error('error :: nonNegativeDerivative failed on resampled_aligned_timeseries for %s - %s' % (
                metric, err))

    if resampled_aligned_timeseries:
        # Replace the period data in the Graphite timeseries with the data
        # in the downsampled timeseries
        logger.info('creating aligned downsampled_timeseries for %s' % metric)
        first_aligned_timestamp = resampled_aligned_timeseries[0][0]
        for ts, v in timeseries:
            if int(ts) < first_aligned_timestamp:
                downsampled_timeseries.append([int(ts), v])
            else:
                break
        downsampled_timeseries = downsampled_timeseries + resampled_aligned_timeseries
        logger.info('created aligned downsampled_timeseries for %s with %s data points' % (
            metric, str(len(downsampled_timeseries))))

    return downsampled_timeseries
